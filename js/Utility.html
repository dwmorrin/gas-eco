<script>
/** Utility */
/* global app toast */
let utility = { DOM: {}, date: {}, item: {}, };

/**
 * TODO this should be to an Item constructor
 */
utility.cleanItem = item => {
  item = item.replace(/\s/g, '').replace(/-0+/, '-');
  return item;
};

/**
 * TODO this should be moved to a Student constructor
 */
utility.cleanStudent = (value, index, array) => {
  array[index] = array[index].replace(/\s/g, '');
},

/**
 * strip is a callback function for array.prototype.forEach
 *   used by the "copy to clipboard" UI element to create a minified
 *   JSON string of items
 * TODO this should be moved to an Item constructor
 */
utility.item.strip = (value, index, array) => {
  // only quantity and barcode needed; getCached gets other info
  array[index] = {
    id: array[index].id,
    description: array[index].description,
    quantity: array[index].quantity,
    barcode: array[index].barcode,
  };
},

/**
 * getCached is a callback function for array.protype.forEach
 *   used by the "copy to clipboard" UI element to verify that non-manual
 *   items match the records in the inventory
 * TODO this should be moved to an Item constructor
 */
utility.item.getCached = (item, index, array) => {
  const items = app.inventory;
  // rebuild item from inventory record
  const cachedItem = items.find(_item => _item.barcode == item.barcode);
  if (cachedItem) {
    item.description = cachedItem.description;
    item.serialized = cachedItem.serialized;
    if (item.serialized) {
      item.quantity = 1;
    }
    item.id = cachedItem.id;
  }
  if (cachedItem || /^MANUAL/.test(item.id)) {
    item.checkedOut = true;
    item.checkIn = null;
    item.checkOut = null;
    item.missing = false;
    item.notes = '';
    return;
  } 
  // removes the item if not manual and not found in inventory.
  app.modal.handleError(new Error(
    'Oops!, "' + item.description + '" ' + 'was not found in our inventory. ' +
    'If this was a manual item, try entering it as a new manual item.'
  ));
  delete array[index];
},

utility.copyToClipboard = function(data) {
  const textArea = document.createElement("textarea");
  // ensures that copying the items will not cause the screen to scroll down
  textArea.setAttribute('readonly', true);
  textArea.value = data;
  document.body.appendChild(textArea);
  textArea.select();
  document.execCommand('copy');
  toast("Items copied");
  // removes the text area after copying so that it is not seen
  document.body.removeChild(textArea);
};

utility.digestMessage = function(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  return window.crypto.subtle.digest('SHA-1', data);
};

utility.hexString = function(buffer) {
  const byteArray = new Uint8Array(buffer);
  const hexCodes = [...byteArray].map(value => {
    const hexCode = value.toString(16);
    const paddedHexCode = hexCode.padStart(2, '0');
    return paddedHexCode;
  });
  return hexCodes.join('');
};

utility.uncamelCase = function(string) {
  return string.replace(/([A-Z])/g, ' $1').replace(/^./,str => str.toUpperCase());
};

utility.DOM.empty = function(element) {
  while(element.firstChild) {
    element.removeChild(element.firstChild);
  }
};

utility.DOM.getFirstChild = function(element) {
  let firstChild = element.firstChild;
  while(firstChild != null && firstChild.nodeType == 3) {
    firstChild = firstChild.nextSibling;
  }
  return firstChild;
};

utility.DOM.getNextSibling = function(element) {
  let nextSibling = element.nextSibling;
  while(nextSibling != null && nextSibling.nodeType == 3) {
    nextSibling = nextSibling.nextSibling;
  }
  return nextSibling;
};

utility.DOM.makeRadio = function(name, ...values) {
  const radio = {};
  for (let value of values) {
    radio[value] = `<input type="radio" name="${name}" value="${value}" `;
    if (value == 'other') {
      radio[value] += 'checked';
    }
    radio[value] += '/>';
  }
  return radio;
};

utility.DOM.makeTableRow = function(tagName, ...strings) {
  const cells = [];
  for (let i = 0, l = strings.length; i < l ; i++) {
    cells.push(document.createElement(tagName));
    cells[i].innerHTML = strings[i];
  }
  const row = document.createElement('tr');
  while(cells.length) {
    row.appendChild(cells.shift());
  }
  return row;
};

utility.DOM.getRadioValue = function() {
  const radio = app.modal.table.querySelectorAll('input[type="radio"]');
  for (let i = 0; i < radio.length; i++) {
    if (radio[i].checked) {
      return radio[i].value;
    }
  }
  return null;
};

utility.date.getFormattedDate = function(date) {
  const year = date.getFullYear(),
        month = (date.getMonth() + 1), // zero indexed
        day = date.getDate(),
        minutes = date.getMinutes();
  let ampm = 'am',
      hour = date.getHours();

  if (hour > 11) {
    ampm = 'pm';
    hour = hour % 12;
  }
  if (hour == 0) {
    hour = 12;
  }
  return utility.date.zeropad(month) + '/' + utility.date.zeropad(day) + '/' +
    year + ' ' + utility.date.zeropad(hour) + ':' +
    utility.date.zeropad(minutes) + ' ' + ampm;
};

/**
 * checks all date/time inputs and returns and object with two Date objects
 * @return {object} - use .startTime and .endTime
 */
utility.date.parseDateAndTimeInputs = function() {
  let startTime = new Date(app.pages.form.elements.form.startDate.value + 'T00:00:00'),
      endTime = new Date(app.pages.form.elements.form.endDate.value + 'T00:00:00'),
      startHour = +app.pages.form.elements.form.startHour.value,
      endHour = +app.pages.form.elements.form.endHour.value,
      startMinute = +app.pages.form.elements.form.startMinute.value,
      endMinute = +app.pages.form.elements.form.endMinute.value;
  const ampmConverter = (ampm, hour) => {
    if (ampm == 'PM' && hour != 12) {
      hour += 12;
    } else if (ampm == 'AM' && hour == 12) { // i.e. 12 AM
      hour = 0;
    }
    return hour;
  };
  startHour = ampmConverter(app.pages.form.elements.form.startAMPM.value, startHour);
  endHour = ampmConverter(app.pages.form.elements.form.endAMPM.value, endHour);
  startTime.setHours(startHour);
  startTime.setMinutes(startMinute);
  endTime.setHours(endHour);
  endTime.setMinutes(endMinute);

  return {startTime, endTime};
};

/**
 * @param {string} dateString
 * @return {Date}
 */
utility.date.parseFormattedDate = function(dateString) {
  // mm/dd/yyyy hh:mm am
  let month   = dateString.slice(0,2),
      day     = dateString.slice(3,5),
      year    = dateString.slice(6,10),
      hour    = dateString.slice(11,13),
      minutes = dateString.slice(14,16),
      ampm    = dateString.slice(17,19);
  // convert ampm to 24 hour
  if (ampm == 'pm') {
    ampm = 12;
  } else {
    ampm = 0;
  }
  hour = hour % 12 + ampm;

  return new Date(year + '-' + utility.date.zeropad(month) + '-' +
           utility.date.zeropad(day) + 'T' + utility.date.zeropad(hour) + ':' +
           utility.date.zeropad(minutes) + ':00'
  );
};

utility.date.roundMinutes = function(minutes) {
  let minute = minutes % 10;
  if (minute < 5) { // roll back to :00
    minutes -= minute;
  } else { // roll back to :05
    minutes -= minute - 5;
  }
  return minutes;
};

utility.date.parseHours = function(hours) {
  if (hours > 12) {
    return hours - 12;
  } else if (hours == 0) {
    return hours + 12;
  } else {
    return hours;
  }
};

utility.date.parseAMPM = function(hours) {
  if (hours >= 12) {
    return 'PM';
  } else {
    return 'AM';
  }
};

utility.date.zeropad = function(x) {
  x = +x;
  if (x < 10) {
    return '0' + x;
  } else {
    return x;
  }
};

/**
 * @param {string} [prefix] - optional prefix to note
 *   usage: undefined for global notes, "John Doe: " for student
 */
utility.saveNote = function(prefix) {
  if (! prefix) {
    prefix = "";
  }
  const input = app.modal.getText();
  if (input.length < 1) {
    return;
  }
  const notes = JSON.parse(app.pages.form.elements.form.notes.value);
  const note = {
    timestamp: Date.now(),
    author: app.elements.usernameDisplay.textContent,
    body: prefix + input,
  };
  let shortNotes = note.body;
  if (shortNotes.length > 10) {
    shortNotes = shortNotes.slice(0, 10) + "...";
  }
  const change = {
    target: {
      name: 'notes',
      value: shortNotes
    }
  };
  const p = document.createElement('p');
  p.textContent = 'Note: ' + '[' + note.author + '] ' + note.body;

  notes.push(note);
  app.pages.form.elements.form.notes.value = JSON.stringify(notes);
  app.pages.form.handleChange(change);

  app.pages.form.elements.noteSection.appendChild(p);
  if (app.pages.form.elements.noteSection.classList.contains('hidden')) {
    app.pages.form.elements.noteSection.classList.remove('hidden');
  }
};
</script>
