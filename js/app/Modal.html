<script>
/* global
      app
      utility
*/
app.modal = {
  body:         document.querySelector('div.modal p'),
  cancel:       document.querySelector('button.modalcancel'),
  container:    document.querySelector('div.modal'),
  heading:      document.querySelector('div.modal h1'),
  input:        document.querySelector('div.modal input'),
  link:         document.querySelector('div.modal a'),
  ok:           document.querySelector('button.modalok'),
  overlay:      document.querySelector('div.overlay'),
  table:        document.querySelector('div.modal table'),
  textarea:     document.querySelector('div.modal textarea'),
  tmp: undefined, // stores strings (although not restricted to strings only, usually some key needed if user selects 'ok'

  strings: {
    ambiguous: {
      heading: "Check in or out?",
      body:    "",
      ok:      "",
    },
    changes: {
      heading: "Change Log",
      body:    "",
      ok:      "",
    },
    checkOutAgain: {
      heading: "Check out again?",
      body:    " was already checked back in.",
      ok:      "Check out again",
    },
    codabar: {
      heading: "ID not recognized",
      body:    "If you scanned an ID, add it to the student's info by " +
               "submitting their NetID.  If you think you are seeing this " +
               "message in error, choose \"close\".",
      ok:      "Submit",
    },
    collision: {
      heading: "Uh-oh, your form conflicts with another form",
      body:    "Unfortunately, no automatic fix is available, but your form " +
               "has been saved.  To keep viewing your form, choose \"Close\".",
      ok:      "Switch to the saved form"
    },
    init: { // as defined in html/Modal.html
      heading: "Attention",
      body:    "choose an option to exit",
      ok:      "Ok",
    },
    itemQuantity: {
      heading: "Change Quantity",
      body:    "Enter the new quantity:",
      ok:      "Set Quantity",
    },
    error: {
      heading: "Error",
      body:    "an error has occured",
      ok:      "ok",
    },
    itemNote: {
      heading: "Add notes to item",
      body:    "",
      ok:      "Submit",
    },
    location: {
      heading: "Location: Other",
      body:    "Equipment may not be taken off of the 5th floor of " +
               "194 Mercer Street.",
      ok:      "Set location",
    },
    note: {
      heading: "New note",
      body:    "Enter a note",
      ok:      "Save note",
    },
    manual: {
      heading: "Check out item without barcode",
      body:    "Describe the item: (required, provide as much detail as possible)",
      ok:      "Check Out",
    },
    manualEntryAlert: {
      heading: "Use scanner if you can",
      body:    /* value */ " appears to have been something you typed at the " +
               "keyboard. Use the barcode scanner for student IDs and items.",
      ok:      "",
    },
    signatureReady: {
      heading: "Add signature",
      body:    "Production area policy acknowledgment signature not found " +
               "for this person. All persons must read the policy and have " +
               "a signature on file. Please use the tablet to show the " +
               "person the policy and capture their signature. " +
               "Click the 'Signature Done/Recheck' when they are finished " +
               "using the tablet.",
      ok:      "Signature Done/Recheck",
    },
    signatureWait: {
      heading: "Add signature",
      body:    "Please wait...",
      ok:      "",
    },
    studentNote: {
      heading: "Add notes to student",
      body:    "",
      ok:      "Submit",
    },
    undo: {
      heading: "Undo all changes",
      body:    "Do you want to undo all changes since the last save?",
      ok:      "Revert to saved form",
    },
    unsaved: {
      heading: "Warning, your changes are not saved",
      body:    "Are you sure?",
      ok:      "Lose Changes",
    },
  },

  // modal methods
  /**
   @param {[]} notes - saved notes, query changes for pending changes
   */
  displayChangeLog: function(notes) {
    utility.DOM.empty(app.modal.table);
    app.modal.table.appendChild(utility.DOM.makeTableRow('th', 'Time', 'User', 'Field', 'Value'));
    // display saved changes
    for(let note of notes) {
      try {
        let changes = JSON.parse(note.body);
        for(let change of changes) {
          app.modal.table.appendChild(
            utility.DOM.makeTableRow(
              'td',
              utility.date.getFormattedDate(new Date(change.timestamp)),
              note.author,
              utility.uncamelCase(change.name),
              change.value
            )
          );
        }
      } catch(e) {
        // this is a global note
      }
    }
    // display pending changes
    for(let change of app.changes.stack) {
      app.modal.table.appendChild(
        utility.DOM.makeTableRow(
          'td',
          utility.date.getFormattedDate(new Date(change.timestamp)),
          app.elements.usernameDisplay.textContent, // note difference with saved changes!
          utility.uncamelCase(change.name),
          change.value
        )
      );
    }

    app.modal.setStrings('changes');
    app.modal.show(app.modal.container, app.modal.table);
  },

  blurAllTextInputs: function() {
    let textInputs = document.querySelectorAll('input[type="text"]');
    for(var i = 0, l = textInputs.length; i < l; i++) {
      textInputs[i].blur();
    }
  },

  getInput: function () {
    return app.modal.getValueAndClear(app.modal.input);
  },

  getLocation: function() {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('location');
    app.modal.input.setAttribute('placeholder', 'enter location name');
    app.modal.ok.setAttribute('value', 'setLocationOther');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.input);
  },

  getNewCodabar: function(codabar /* string */) {
    app.modal.input.setAttribute('placeholder', "enter student's NetID");
    app.modal.blurAllTextInputs();
    app.modal.setStrings('codabar');
    app.modal.ok.setAttribute('value', 'codabar');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.input);
    app.modal.tmp = codabar;
  },

  getNote: function() {
    app.modal.setStrings('note');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.textarea);
    app.modal.ok.setAttribute('value', 'saveNote');
    app.modal.textarea.focus();
  },
  getManual: function() {
    app.modal.setStrings('manual');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.textarea);
    app.modal.ok.setAttribute('value', 'saveManual');
    app.modal.textarea.focus();
  },
  getText: function() {
    return app.modal.getValueAndClear(app.modal.textarea);
  },

  // Interface for inputs, this is a private function, public calls getInput, getText
  getValueAndClear: function(inputElement) {
    let value = inputElement.value.trim();
    inputElement.value = '';
    return value;
  },

  handleAmbiguousItemAction: function(item) {
    this.tmp = item;
    this.setStrings("ambiguous");
    this.blurAllTextInputs();
    this.body.textContent = 'Item: ' + item.description;
    utility.DOM.empty(this.table);
    this.table.appendChild(
      utility.DOM.makeTableRow(
        'td', "Check the item back in?",
        `<button value="ambiguousCheckIn">Check In</button>`
      )
    );
    this.table.appendChild(
      utility.DOM.makeTableRow(
        'td', "Check out more of these",
        `<button value="ambiguousCheckOut">Check Out</button>`
      )
    );
    this.show(this.container, this.table);
  },

  handleCheckOutAgain: function(item) {
    this.setStrings("checkOutAgain");
    this.body.textContent = item.description + this.body.textContent;
    this.ok.setAttribute("value", "checkOutAgain");
    this.tmp = item;
    this.show(this.container, this.ok);
  },

  /**
   * @param {obj} collision - has properties {obj} form, {obj} submittedForm
   */
  handleCollision: function(collision) {
    const m = app.modal;
    m.tmp = collision;
    m.setStrings("collision");
    m.ok.setAttribute('value', 'collisionResolve');
    m.show(m.container, m.ok);
  },

  handleError: function(error) {
    app.errors.push(error);
    if (app.modal.heading.textContent != app.modal.strings.error.heading) {
      app.modal.showNextError();
    } // else the user is already seeing an error message
    // modal.hide will call showNextError when user is ready
  },

  /**
   * @param {Obj} info - an object with a 'message' string member
   */
  handleInfo: function(info) {
    app.errors.push(info);
    if (app.modal.heading.textContent != app.modal.strings.error.heading) {
      app.modal.showNextError();
    }
  },

  isShowing: function () {
    return ! app.modal.container.classList.contains("hidden");
  },

  signatureReady: function() {
    let m = app.modal;
    m.setStrings('signatureReady');
    m.show(app.modal.container, app.modal.ok, app.modal.link);
    m.ok.setAttribute('value', 'signatureRecheck');
  },

  signatureWait: function() {
    let m = app.modal;
    m.setStrings('signatureWait');
    m.show(app.modal.container);
  },

  showNextError: function() {
    let error = app.errors.shift();
    if (! error) {
      return;
    }
    app.modal.blurAllTextInputs();
    app.modal.setStrings('error');
    if(error.message) {
      app.modal.body.textContent = error.message;
      app.modal.show(app.modal.container);
    } else if (error.target == 'collision') {
      app.modal.handleCollision(error);
    }
  },

  handleItemNote: function(item) {
    const m = app.modal,
          radio = utility.DOM.makeRadio('itemOptions', 'missing', 'other');
    m.blurAllTextInputs();
    m.setStrings('itemNote');
    m.body.textContent = 'Item: ' + item.description;
    utility.DOM.empty(m.table);
    if(!item.checkIn && !item.missing) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Item cannot be found', radio['missing']
        )
      );
    }
    m.table.appendChild(
      utility.DOM.makeTableRow(
        'td', 'Other (please specify below)', radio['other']
      )
    );
    app.modal.ok.setAttribute('value', 'itemNote');
    app.modal.tmp = item;
    m.show(m.container, m.table, m.textarea, m.ok);
    m.textarea.focus();
  },

  handleKeydown: function(key) {
    if (key == 'Enter') {
      this.hide();
      app.doCommand(this.ok.value);
    }
  },

  handleQuantityChange: function(item) {
    if (! item || item.isSerialized()) {
      return;
    }
    const m = app.modal;
    m.blurAllTextInputs();
    m.ok.setAttribute('value', 'itemQuantity');
    app.modal.input.setAttribute('placeholder', '');
    m.tmp = item; // so we can asynchronously fetch if user selects OK
    m.setStrings('itemQuantity');
    m.body.textContent += ` (current quantity: ${item.getQuantity()})`;
    m.show(m.container, m.input, m.ok);
    m.input.focus();
  },

  /** using the table as a form container, along with the textarea for open ended input */
  handleStudentNote: function(student) {
    const m = app.modal,
          radio = utility.DOM.makeRadio('studentOptions', 'no show', 'left', 'other');
    m.blurAllTextInputs();
    m.setStrings('studentNote');
    m.body.textContent = 'Name: ' + student.name;
    utility.DOM.empty(m.table);
    if (! student.checkIn) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Student never showed up', radio['no show']
        )
      );
    } else if (!student.checkOut && !student.left) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Student left without checking out', radio['left']
        )
      );
    }
    m.table.appendChild(
      utility.DOM.makeTableRow(
        'td', 'Other (please specify below)', radio['other']
      )
    );
    m.ok.setAttribute('value', 'studentNote');
    m.tmp = student;
    m.show(m.container, m.table, m.textarea, m.ok);
    m.textarea.focus();
  },

  handleUndo: function() {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('undo');
    app.modal.ok.setAttribute('value', 'loseData_revert');
    app.modal.show(app.modal.container, app.modal.ok);
  },

  handleUnsavedForm: function(buttonValue) {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('unsaved');
    app.modal.ok.setAttribute('value', 'loseData_' + buttonValue);
    app.modal.show(app.modal.container, app.modal.ok);
  },

  hide: function() {
    // check if more errors need to be displayed
    if (app.errors.length > 0) {
      app.modal.showNextError();
      return;
    }
    // unlock form if cancelling from collision
    if (app.modal.heading.textContent == app.modal.strings.collision.heading) {
      app.pages.form.unlock();
    }
    // hide whatever is hidden by default
    let elements = [
      app.modal.container, app.modal.ok, app.modal.input, app.modal.overlay,
      app.modal.table, app.modal.textarea, app.modal.link
    ];
    for(let el of elements) {
      el.classList.add('hidden');
    }
    // use default heading so we can check heading for state
    app.modal.heading.textContent = app.modal.strings.init.heading;
    // focus omnibox if viewing single form
    if (app.pages.form.isShowing()) {
      app.omnibox.element.focus();
    }
  },

  manualEntryAlert: function(entry) {
    app.pages.form.handleChange({
      target: {
        name: "manual",
        value: entry
      }
    });
    app.modal.blurAllTextInputs();
    app.modal.setStrings("manualEntryAlert");
    app.modal.body.textContent = "\"" + entry + "\"" +
      app.modal.body.textContent;
    app.modal.show(app.modal.container);
  },
  
  setStrings: function(key) {
    for(let element in app.modal.strings[key]) {
      app.modal[element].textContent = app.modal.strings[key][element];
    }
  },

  show: function(...elements) {
    app.modal.overlay.classList.remove('hidden');
    for(let el of elements) {
      el.classList.remove('hidden');
    }
  },
};
</script>
