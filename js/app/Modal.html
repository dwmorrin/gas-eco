<script>
/* global
      app
      SignaturePad
      utility
*/
app.modal = {
  body:         document.querySelector('div.modal p'),
  cancel:       document.querySelector('button.modalcancel'),
  canvas:       document.querySelector('div.modal canvas'),
  clear:        document.querySelector('button.signatureclear'),
  container:    document.querySelector('div.modal'),
  heading:      document.querySelector('div.modal h1'),
  input:        document.querySelector('div.modal input'),
  link:         document.querySelector('div.modal a'),
  ok:           document.querySelector('button.modalok'),
  overlay:      document.querySelector('div.overlay'),
  signaturePad: new SignaturePad(document.querySelector('div.modal canvas')),
  table:        document.querySelector('div.modal table'),
  textarea:     document.querySelector('div.modal textarea'),
  tmp: undefined, // stores strings (although not restricted to strings only, usually some key needed if user selects 'ok'

  strings: {
    changes: {
      heading: "Change Log",
      body:    "",
      ok:      "",
    },
    codabar: {
      heading: "ID not recognized",
      body:    "If you scanned an ID, add it to the student's info by " +
               "submitting their NetID.  If you think are seeing this " +
               "message in error, choose \"close\".",
      ok:      "Submit",
    },
    collision: {
      heading: "Uh-oh, your form conflicts with another form",
      body:    "Unfortunately, no automatic fix is available. Please write down " +
               "the details of your form, then refresh and open the form again. " +
               "Modify the newly opened form to reflect the changes you want. " +
               "Check to log to see what changes caused the conflict.",
      ok:      "Ok"
    },
    init: { // as defined in html/Modal.html
      heading: "Attention",
      body:    "choose an option to exit",
      ok:      "Ok",
    },
    itemQuantity: {
      heading: "Change Quantity",
      body:    "Enter the new quantity:",
      ok:      "Set Quantity",
    },
    error: {
      heading: "Error",
      body:    "an error has occured",
      ok:      "ok",
    },
    itemNote: {
      heading: "Add notes to item",
      body:    "",
      ok:      "Submit",
    },
    location: {
      heading: "Location: Other",
      body:    "Equipment may not be taken off of the 5th floor of " +
               "194 Mercer Street.",
      ok:      "Set location",
    },
    note: {
      heading: "New note",
      body:    "Enter a note",
      ok:      "Save note",
    },
    manual: {
      heading: "Check out item without barcode",
      body:    "Describe the item: (provide as much detail as possible)",
      ok:      "Check Out",
    },
    signature: {
      heading: "Signature Confirmation:",
      body:    "My signature here confirms that I have read and understand " +
               "Recorded Music's policies governing the use of its music " +
               "production facilities.  I am aware that I am responsible " +
               "for the conduct of my guests (including my teammates and " +
               "other Recorded Music Students), and I understand that " +
               "failure to follow those policies could result in fines " +
               "and/or the loss of privileges.",
      ok:      "Submit Signature",
    },
    signatureReady: {
      heading: "Add signature",
      body:    "A signature was not found for this person.  " +
               "Please use the tablet to get the student signature then " +
               "click the done button.",
      ok:      "Signature Done/Recheck",
    },
    signatureWait: {
      heading: "Add signature",
      body:    "Please wait...",
      ok:      "",
    },
    studentNote: {
      heading: "Add notes to student",
      body:    "",
      ok:      "Submit",
    },
    undo: {
      heading: "Undo all changes",
      body:    "Do you want to undo all changes since the last save?",
      ok:      "Revert to saved form",
    },
    unsaved: {
      heading: "Warning, your changes are not saved",
      body:    "Are you sure?",
      ok:      "Lose Changes",
    },
  },

  // modal methods
  /**
   @param {[]} notes - saved notes, query changes for pending changes
   */
  displayChangeLog: function(notes) {
    utility.DOM.empty(app.modal.table);
    app.modal.table.appendChild(utility.DOM.makeTableRow('th', 'Time', 'User', 'Field', 'Value'));
    // display saved changes
    for(let note of notes) {
      try {
        let changes = JSON.parse(note.body);
        for(let change of changes) {
          app.modal.table.appendChild(
            utility.DOM.makeTableRow(
              'td',
              utility.date.getFormattedDate(new Date(change.timestamp)),
              note.author,
              utility.uncamelCase(change.name),
              change.value
            )
          );
        }
      } catch(e) {
        // this is a global note
      }
    }
    // display pending changes
    for(let change of app.changes.stack) {
      app.modal.table.appendChild(
        utility.DOM.makeTableRow(
          'td',
          utility.date.getFormattedDate(new Date(change.timestamp)),
          app.elements.usernameDisplay.textContent, // note difference with saved changes!
          utility.uncamelCase(change.name),
          change.value
        )
      );
    }

    app.modal.setStrings('changes');
    app.modal.show(app.modal.container, app.modal.table);
  },

  blurAllTextInputs: function() {
    let textInputs = document.querySelectorAll('input[type="text"]');
    for(var i = 0, l = textInputs.length; i < l; i++) {
      textInputs[i].blur();
    }
  },

  getInput: function () {
    return app.modal.getValueAndClear(app.modal.input);
  },

  getLocation: function() {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('location');
    app.modal.input.setAttribute('placeholder', 'enter location name');
    app.modal.ok.setAttribute('value', 'setLocationOther');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.input);
  },

  getNewCodabar: function(codabar /* string */) {
    app.modal.tmp = codabar;
    app.modal.input.setAttribute('placeholder', "enter student's NetID");
    app.modal.blurAllTextInputs();
    app.modal.setStrings('codabar');
    app.modal.ok.setAttribute('value', 'codabar');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.input);
  },

  getNote: function() {
    app.modal.setStrings('note');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.textarea);
    app.modal.ok.setAttribute('value', 'saveNote');
    app.modal.textarea.focus();
  },
  getManual: function() {
    app.modal.setStrings('manual');
    app.modal.show(app.modal.container, app.modal.ok, app.modal.textarea);
    app.modal.ok.setAttribute('value', 'saveManual');
    app.modal.textarea.focus();
  },
  getSignature: function(student) {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('signature');
    // important: call show() before setting canvas width
    // otherwise signature pad will have size of 0
    app.modal.show(
      app.modal.container, app.modal.ok, app.modal.clear, app.modal.canvas
    );
    app.modal.canvas.width = app.modal.container.getBoundingClientRect().width;
    app.modal.ok.setAttribute('value', 'signatureSubmit');
    app.modal.tmp = student.netId;
  },

  getText: function() {
    return app.modal.getValueAndClear(app.modal.textarea);
  },

  // Interface for inputs, this is a private function, public calls getInput, getText
  getValueAndClear: function(inputElement) {
    let value = inputElement.value.trim();
    inputElement.value = '';
    return value;
  },

  handleCollision: function(/* collision */) {
    const m = app.modal;
    m.setStrings("collision");
    m.show(app.modal.container);
  },

  handleError: function(error) {
    app.errors.push(error);
    if (app.modal.heading.textContent != app.modal.strings.error.heading) {
      app.modal.showNextError();
    } // else the user is already seeing an error message
    // modal.hide will call showNextError when user is ready
  },

  /**
   * @param {Obj} info - an object with a 'message' string member
   */
  handleInfo: function(info) {
    app.errors.push(info);
    if (app.modal.heading.textContent != app.modal.strings.error.heading) {
      app.modal.showNextError();
    }
  },

  signatureReady: function() {
    let m = app.modal;
    m.setStrings('signatureReady');
    /* m.link.setAttribute('href', 'https://script.google.com/macros/s/' +
    'AKfycbzoGVb3LFX-Sfxy3_EyMtRYv1TPylDitmuUc-3F7g9mppa_ihEc/exec');
    m.link.textContent = ""; */
    m.show(app.modal.container, app.modal.ok, app.modal.link);
    m.ok.setAttribute('value', 'signatureRecheck');
  },

  signatureWait: function() {
    let m = app.modal;
    m.setStrings('signatureWait');
    m.show(app.modal.container);
  },

  showNextError: function() {
    let error = app.errors.shift();
    if (! error) {
      return;
    }
    app.modal.blurAllTextInputs();
    app.modal.setStrings('error');
    if(error.message) {
      app.modal.body.textContent = error.message;
      app.modal.show(app.modal.container);
    } else if (error.target == 'collision') {
      app.modal.handleCollision(error);
    }
  },

  handleItemNote: function(item) {
    const m = app.modal,
          radio = utility.DOM.makeRadio('itemOptions', 'missing', 'other');
    m.blurAllTextInputs();
    m.setStrings('itemNote');
    m.body.textContent = 'Item: ' + item.description;
    utility.DOM.empty(m.table);
    if(!item.checkIn && !item.missing) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Item cannot be found', radio['missing']
        )
      );
    }
    m.table.appendChild(
      utility.DOM.makeTableRow(
        'td', 'Other (please specify below)', radio['other']
      )
    );
    app.modal.ok.setAttribute('value', 'itemNote');
    app.modal.tmp = item;
    m.show(m.container, m.table, m.textarea, m.ok);
    m.textarea.focus();
  },

  handleQuantityChange: function(itemDescription) {
    // get item
    const items = JSON.parse(app.pages.form.elements.form.items.value);
    const item = items.find(i => i.description == itemDescription);
    if (! item || item.serialized) {
      return;
    }
    const m = app.modal;
    m.blurAllTextInputs();
    m.ok.setAttribute('value', 'itemQuantity');
    m.tmp = itemDescription;
    m.setStrings('itemQuantity');
    m.show(m.container, m.input, m.ok);
    m.input.focus();
  },

  /** using the table as a form container, along with the textarea for open ended input */
  handleStudentNote: function(student) {
    const m = app.modal,
          radio = utility.DOM.makeRadio('studentOptions', 'no show', 'left', 'other');
    m.blurAllTextInputs();
    m.setStrings('studentNote');
    m.body.textContent = 'Name: ' + student.name;
    utility.DOM.empty(m.table);
    if (! student.checkIn) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Student never showed up', radio['no show']
        )
      );
    } else if (!student.checkOut && !student.left) {
      m.table.appendChild(
        utility.DOM.makeTableRow(
          'td', 'Student left without checking out', radio['left']
        )
      );
    }
    m.table.appendChild(
      utility.DOM.makeTableRow(
        'td', 'Other (please specify below)', radio['other']
      )
    );
    m.ok.setAttribute('value', 'studentNote');
    m.tmp = student;
    m.show(m.container, m.table, m.textarea, m.ok);
    m.textarea.focus();
  },

  handleUndo: function() {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('undo');
    app.modal.ok.setAttribute('value', 'revert');
    app.modal.show(app.modal.container, app.modal.ok);
  },

  handleUnsavedForm: function(buttonValue) {
    app.modal.blurAllTextInputs();
    app.modal.setStrings('unsaved');
    app.modal.ok.setAttribute('value', 'loseData_' + buttonValue);
    app.modal.show(app.modal.container, app.modal.ok);
  },

  hide: function() {
    // check if more errors need to be displayed
    if(app.errors.length > 0) {
      app.modal.showNextError();
      return;
    }
    // hide whatever is hidden by default
    let elements = [
      app.modal.container, app.modal.ok, app.modal.canvas, app.modal.clear,
      app.modal.input, app.modal.overlay, app.modal.table, app.modal.textarea,
      app.modal.link
    ];
    for(let el of elements) {
      el.classList.add('hidden');
    }
    // use default heading so we can check heading for state
    app.modal.heading.textContent = app.modal.strings.init.heading;
  },

  setStrings: function(key) {
    for(let element in app.modal.strings[key]) {
      app.modal[element].textContent = app.modal.strings[key][element];
    }
  },

  show: function(...elements) {
    app.modal.overlay.classList.remove('hidden');
    for(let el of elements) {
      el.classList.remove('hidden');
    }
  },
};
</script>
